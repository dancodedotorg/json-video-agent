# Google ADK Imports
from google.adk.agents.llm_agent import Agent
from google.adk.agents.callback_context import CallbackContext
from google.adk.tools import ToolContext

# Shared imports
from ..shared.constants import GEMINI_MODEL
from ..shared.tools import list_grounding_artifacts, list_current_state, _maybe_extract_json
from .audio_tag_prompt import AUDIO_TAGS_PROMPT, AUDIO_TAGS_DESCRIPTION

# Utilities
from typing import Any, Dict, List
from pydantic import BaseModel, Field, ValidationError, ConfigDict
import logging
import copy

# --- Structured Output ---
# 1. Define the structure for a single JSON object (an item in the list)
class RefinedScene(BaseModel):
    """A single scene containing a comment and speech"""
    model_config = ConfigDict(extra="allow")
    comment: str = Field(description="A 1-sentence metadata comment for the generated scene")
    speech: str = Field(description="The voiceover speech for this particular scene")
    elevenlabs: str = Field(description="The augmented ElevenLabs voiceover")

# 2. Define the overall structure (a list of CodeProblem objects)
class RefinedSceneList(BaseModel):
    """A list of one or more scenes."""
    model_config = ConfigDict(extra="allow")
    scenes: List[RefinedScene]


def commit_refined_voiceover_scenes(json_str: str, tool_context: ToolContext) -> Dict[str, Any]:
    """Updates the session state with the in-progress scenes being generated between the agent and the user.
    
    This tool commits the in-progress voiceover scenes being generated by the agent to the session state under 'initial_voiceover_scenes'.
    **Input Format:** The json_str input must conform to the RefinedSceneList schema, containing an array of scenes:
    {
      "scenes": [
        {
          "comment": "A brief comment about the scene",
          "speech": "The voiceover speech for this scene.",
          "elevenlabs": "augmented elevenlabs voiceover with audio tags"
        },
        ...
      ]
    }
    do NOT include any preamble, such as ```json ``` or explanations - ONLY provide the JSON object.

    Args:
        json_str: The voiceover scenes as a str, conforming to the RefinedSceneList schema above.
        tool_context: ADK ToolContext automatically injected at runtime for state/artifact management
    
    Returns:
        Dict containing a status (str): "success" or "error", and additional information about the session state"""
    candidate_json = _maybe_extract_json(json_str)
    # Validate the JSON against the SceneList schema
    try:
        scenes = RefinedSceneList.model_validate_json(candidate_json)
    except ValidationError as e:
        return {
            "status": "error",
            "message": f"Provided JSON does not conform to SceneList schema: {e}"
        }

    # If we made it here: it worked!
    json_obj = scenes.model_dump()
    tool_context.state["refined_voiceover_scenes"] = json_obj
    return {
        "status": "success",
        "message": "Initial voiceover scenes committed to state.",
        "refined_voiceover_scenes": json_obj
    }

# ----------------------------
# Agent
# ----------------------------

def before_agent_preload_state(callback_context: CallbackContext):
    # when entering agent: take existing top-level scenes and populate locally for this agent
    temp = copy.deepcopy(callback_context.state["scenes"])
    callback_context.state["refined_voiceover_scenes"] = {
        "scenes": temp
    }

def after_agent_adjust_state(callback_context: CallbackContext):
    # when entering agent: take existing top-level scenes and populate locally for this agent
    temp = copy.deepcopy(callback_context.state["refined_voiceover_scenes"])
    callback_context.state["scenes"] = temp["scenes"]


audio_tags_agent = None

try:
    audio_tags_agent = Agent(
        model=GEMINI_MODEL,
        name='audio_tags_agent',
        description=AUDIO_TAGS_DESCRIPTION,
        instruction=AUDIO_TAGS_PROMPT,
        tools=[list_grounding_artifacts, list_current_state, commit_refined_voiceover_scenes],
        # before_agent_callback=before_agent_preload_state,
        # after_agent_callback=after_agent_adjust_state,
    )   
    logging.info(f"✅ Sub-agent '{audio_tags_agent.name}' created using model '{GEMINI_MODEL}'.")
except Exception as e:
    logging.error(f"❌ Failed to create sub-agent 'audio_tags_agent': {e}")